#version 460
#extension GL_GOOGLE_include_directive : enable
#include "../include/common.glsl"

layout(local_size_x = 256) in;

layout(set = 0, binding = 0, std430) readonly buffer Entries { Entry entries[]; };
layout(set = 0, binding = 1, std430) readonly buffer Offsets { uint grid_start[]; };
layout(set = 0, binding = 3, std430) readonly buffer Positions { vec4 positions[]; };

layout(set = 0, binding = 4, std430) writeonly buffer Densities { float densities[]; };
layout(set = 0, binding = 5, std430) writeonly buffer Alphas { float factors[]; };

void main() {
    uint i = gl_GlobalInvocationID.x;
    uint num_particles = uint(positions.length());

    if (i >= num_particles) return;

    vec3 pos_i = positions[i].xyz;
    float h = sim_params.smoothing_radius;
    float mass = sim_params.particle_mass;

    ivec3 cell_coords = ivec3(floor(pos_i / h));
    uint table_size = uint(grid_start.length());

    float density = 0.0;
    float sum_grad_sq = 0.0;
    vec3 grad_sum = vec3(0.0);

    for (int z = -1; z <= 1; z++) {
        for (int y = -1; y <= 1; y++) {
            for (int x = -1; x <= 1; x++) {
                ivec3 neighbor_cell = cell_coords + ivec3(x, y, z);
                uint hash = get_cell_hash(neighbor_cell, table_size);

                uint start_idx = grid_start[hash];

                if (start_idx == 0xFFFFFFFF) continue;

                for (uint j = start_idx; j < num_particles; j++) {
                    if (entries[j].hash != hash) break;

                    vec3 pos_j = positions[j].xyz;
                    vec3 r_vec = pos_i - pos_j;
                    float r2 = dot(r_vec, r_vec);

                    if (r2 > h * h) continue;

                    float r = sqrt(r2);
                    float w = kernel_w(r, h);
                    density += mass * w;

                    if (r > 1e-6) {
                        vec3 grad = kernel_grad(r_vec, r, h);
                        vec3 mass_grad = mass * grad;
                        grad_sum += mass_grad;
                        sum_grad_sq += dot(mass_grad, mass_grad);
                    }
                }
            }
        }
    }

    densities[i] = density;
    float alpha = sum_grad_sq + dot(grad_sum, grad_sum);
    if (alpha > 1e-6) {
        factors[i] = alpha;
    } else {
        factors[i] = 0.0;
    }
}