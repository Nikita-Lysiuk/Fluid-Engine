#version 460
#extension GL_GOOGLE_include_directive : enable
#include "../include/common.glsl"

layout(local_size_x = 256) in;

layout(std430, set = 0, binding = 0) readonly buffer Entries { Entry entries[]; };
layout(std430, set = 0, binding = 1) readonly buffer Offsets { uint grid_start[]; };
layout(std430, set = 0, binding = 3) readonly buffer Positions { vec4 positions[]; };
layout(std430, set = 0, binding = 4) readonly buffer Pressures { float pressures[]; };
layout(std430, set = 0, binding = 5) readonly buffer Densities { float densities[]; };

layout (std430, set = 0, binding = 6) buffer PressureForces { vec4 pressure_forces[]; };

void main() {
    uint i = gl_GlobalInvocationID.x;
    uint num_particles = uint(positions.length());

    if (i >= num_particles) return;

    vec3 pos_i = positions[i].xyz;
    float h = sim_params.smoothing_radius;
    float mass = sim_params.particle_mass;
    float dt = sim_params.dt;

    float rho_i = densities[i];
    float p_i = pressures[i];
    
    float p_rho_i = 0.0;
    if (rho_i > 1e-6) {
        p_rho_i = p_i / (rho_i * rho_i);
    }

    ivec3 cell_coords = ivec3(floor(pos_i / h));
    uint table_size = uint(grid_start.length());


    vec3 accel_sum = vec3(0.0);

    for (int z = -1; z <= 1; z++) {
        for (int y = -1; y <= 1; y++) {
            for (int x = -1; x <= 1; x++) {
                ivec3 neighbor_cell = cell_coords + ivec3(x, y, z);
                uint hash = get_cell_hash(neighbor_cell, table_size);
                uint start_idx = grid_start[hash];

                if (start_idx == 0xFFFFFFFF) continue;

                for (uint j = start_idx; j < num_particles; j++) {
                    if (entries[j].hash != hash) break;

                    vec3 pos_j = positions[j].xyz;
                    vec3 r_vec = pos_i - pos_j;
                    float r2 = dot(r_vec, r_vec);

                    if (r2 > h * h) continue;

                    float r = sqrt(r2);

                    if (r > 1e-6) {
                        float rho_j = densities[j];
                        float p_j = pressures[j];

                        if (rho_j > 1e-6) {
                            vec3 grad = kernel_grad(r_vec, r, h);
                            float p_rho_j = p_j / (rho_j * rho_j);

                            float pressure_term = p_rho_i + p_rho_j;
                            accel_sum += mass * pressure_term * grad;
                        }
                    }
                }
            }
        }
    }

    pressure_forces[i] = vec4(-accel_sum, 0.0);
}